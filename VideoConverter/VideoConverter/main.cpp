//
//  main.cpp
//  VideoConverter
//
//  Created by Li Shuzu on 19/10/17.
//  Copyright Â© 2017 TimePic. All rights reserved.
//

/**
 * @file bg_sub.cpp
 * @brief Background subtraction tutorial sample code
 * @author Domenico D. Bloisi
 */

//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include "opencv2/video/background_segm.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
char keyboard; //input from keyboard

/** Function Headers */
void help();
void processVideo(char* videoFilename);
void processTansVideo(char* videoFilename);
void saveVideo(char* videoFilename);

void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
    << endl
    << "Usage:"                                                                     << endl
    << "./bg_sub {-vid <video filename>|-img <image filename>}"                     << endl
    << "for example: ./bg_sub -vid video.avi"                                       << endl
    << "or: ./bg_sub -img /data/images/1.png"                                       << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

/**
 * @function main
 */
int main(int argc, char* argv[])
{
    //print help information
    help();
    
    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }
    
    //create GUI windows
    namedWindow("Frame");
    namedWindow("FG Mask MOG 2");
    
    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
    
    if(strcmp(argv[1], "-vid") == 0) {
        //input data coming from a video
//        processVideo(argv[2]);
        processTansVideo(argv[2]);
            saveVideo(argv[2]);
    }
    else {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

/**
 * @function processVideo
 */
void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }
    //read input data. ESC or 'q' for quitting
    keyboard = 0;
    while( keyboard != 'q' && keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0, 255, 0));
        //show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        //get the input from the keyboard
        keyboard = (char)waitKey( 30 );
    }
    //delete capture object
    capture.release();
}

void processTansVideo(char* videoFilename){
    
    // Init background substractor
    Ptr<BackgroundSubtractor> bg_model = createBackgroundSubtractorMOG2().dynamicCast<BackgroundSubtractor>();
    
    // Create empy input img, foreground and background image and foreground mask.
    Mat img, foregroundMask, backgroundImage, foregroundImg;
    
    // capture video from source 0, which is web camera, If you want capture video from file just replace //by  VideoCapture cap("videoFile.mov")
    VideoCapture cap(videoFilename);
//    VideoCapture cap(0);


    
    
    // Setup output video
    cv::VideoWriter output_cap("/Users/will/Sites/University/comp594/VideoConverter/out.mp4",
                               cap.get(CV_CAP_PROP_FOURCC),
                               cap.get(CV_CAP_PROP_FPS),
                               cv::Size(cap.get(CV_CAP_PROP_FRAME_WIDTH),
                                        cap.get(CV_CAP_PROP_FRAME_HEIGHT)));
    
    
    if (!output_cap.isOpened())
    {
        std::cout << "!!! Output video could not be opened" << std::endl;
        return;
    }
    

    // main loop to grab sequence of input files
    for(;;){
        
        bool ok = cap.grab();
        
        if (ok == false){
            
            std::cout << "Video Capture Fail" << std::endl ;
            break;
            
        }else{
            
            // obtain input image from source
            cap.retrieve(img, CV_CAP_OPENNI_BGR_IMAGE);
            // Just resize input image if you want
//            resize(img,img,Size(640,480));

            // create foreground mask of proper size
            if( foregroundMask.empty() ){
                foregroundMask.create(img.size(), img.type());
            }
            
            // compute foreground mask 8 bit image
            // -1 is parameter that chose automatically your learning rate
            
            bg_model->apply(img, foregroundMask, true ? -1 : 0);
            
            // smooth the mask to reduce noise in image
            GaussianBlur(foregroundMask, foregroundMask, Size(11,11), 3.5,3.5);
            
            // threshold mask to saturate at black and white values
            threshold(foregroundMask, foregroundMask, 10,255,THRESH_BINARY);
            
            
            
            // create black foreground image
            foregroundImg = Scalar::all(0);
            foregroundImg.setTo(cv::Scalar(0,255,0));
            // Copy source image to foreground image only in area with white mask
            img.copyTo(foregroundImg, foregroundMask);
            
            //Get background image
            bg_model->getBackgroundImage(backgroundImage);
            output_cap.write(foregroundImg);
            // Show the results
//            imshow("foreground mask", foregroundMask);
            imshow("foreground image", foregroundImg);

            int key6 = waitKey(40);
            
            if(!backgroundImage .empty()){
                
//                imshow("mean background image", backgroundImage );
                int key5 = waitKey(40);
                
            }
        
        }

        
    }
    
    cap.release();
    output_cap.release();
}


void saveVideo(char* videoFilename){
    
    VideoCapture vcap(videoFilename);
    if(!vcap.isOpened()){
        cout << "Error opening video stream or file" << endl;
    }
    
    int frame_width=   vcap.get(CV_CAP_PROP_FRAME_WIDTH);
    int frame_height=   vcap.get(CV_CAP_PROP_FRAME_HEIGHT);
    VideoWriter video("out.avi",CV_FOURCC('M','J','P','G'),10, Size(frame_width,frame_height),true);
    
    for(;;){
        
        Mat frame;
        vcap >> frame;
        video.write(frame);
        imshow( "Frame", frame );
        char c = (char)waitKey(33);
        if( c == 27 ) break;
    }

}
